<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>claro.projection documentation</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="highlight/solarized-light.css" /><script type="text/javascript" src="highlight/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a> with <a href="https://github.com/xsc/codox-theme-rdash">RDash UI</a> theme</h2><h1><a href="index.html"><span class="project-title"><span class="project-name">claro</span> <span class="project-version">0.2.20</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1 "><a href="00-basics.html"><div class="inner"><span>Basic Resolution</span></div></a></li><li class="depth-1 "><a href="01-projection.html"><div class="inner"><span>Projections</span></div></a></li><li class="depth-1 "><a href="02-advanced-projection.html"><div class="inner"><span>Advanced Projections</span></div></a></li><li class="depth-1 "><a href="03-engine.html"><div class="inner"><span>Engine</span></div></a></li><li class="depth-1 "><a href="04-testing-and-debugging.html"><div class="inner"><span>Testing &amp; Debugging</span></div></a></li><li class="depth-1 "><a href="99-notes.html"><div class="inner"><span>Implementation Notes</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>claro</span></div></div></li><li class="depth-2"><a href="claro.data.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>data</span></div></a></li><li class="depth-3"><a href="claro.data.ops.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>ops</span></div></a></li><li class="depth-2"><a href="claro.engine.html"><div class="inner"><span class="tree" style="top: -52px;"><span class="top" style="height: 61px;"></span><span class="bottom"></span></span><span>engine</span></div></a></li><li class="depth-3 branch"><a href="claro.engine.adapter.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>adapter</span></div></a></li><li class="depth-3"><a href="claro.engine.selector.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>selector</span></div></a></li><li class="depth-2"><div class="no-link"><div class="inner"><span class="tree" style="top: -83px;"><span class="top" style="height: 92px;"></span><span class="bottom"></span></span><span>middleware</span></div></div></li><li class="depth-3 branch"><a href="claro.middleware.cache.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>cache</span></div></a></li><li class="depth-3 branch"><a href="claro.middleware.deferred.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>deferred</span></div></a></li><li class="depth-3 branch"><a href="claro.middleware.intercept.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>intercept</span></div></a></li><li class="depth-3 branch"><a href="claro.middleware.mock.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>mock</span></div></a></li><li class="depth-3 branch"><a href="claro.middleware.observe.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>observe</span></div></a></li><li class="depth-3"><a href="claro.middleware.transform.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>transform</span></div></a></li><li class="depth-2 current"><a href="claro.projection.html"><div class="inner"><span class="tree" style="top: -207px;"><span class="top" style="height: 216px;"></span><span class="bottom"></span></span><span>projection</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="claro.projection.html#var-alias"><div class="inner"><span>alias</span></div></a></li><li class="depth-1"><a href="claro.projection.html#var-apply"><div class="inner"><span>apply</span></div></a></li><li class="depth-1"><a href="claro.projection.html#var-bind"><div class="inner"><span>bind</span></div></a></li><li class="depth-1"><a href="claro.projection.html#var-case"><div class="inner"><span>case</span></div></a></li><li class="depth-1"><a href="claro.projection.html#var-case-resolvable"><div class="inner"><span>case-resolvable</span></div></a></li><li class="depth-1"><a href="claro.projection.html#var-conditional"><div class="inner"><span>conditional</span></div></a></li><li class="depth-1"><a href="claro.projection.html#var-conditional-union"><div class="inner"><span>conditional-union</span></div></a></li><li class="depth-1"><a href="claro.projection.html#var-default"><div class="inner"><span>default</span></div></a></li><li class="depth-1"><a href="claro.projection.html#var-extract"><div class="inner"><span>extract</span></div></a></li><li class="depth-1"><a href="claro.projection.html#var-extract-in"><div class="inner"><span>extract-in</span></div></a></li><li class="depth-1"><a href="claro.projection.html#var-finite-value"><div class="inner"><span>finite-value</span></div></a></li><li class="depth-1"><a href="claro.projection.html#var-juxt"><div class="inner"><span>juxt</span></div></a></li><li class="depth-1"><a href="claro.projection.html#var-juxt*"><div class="inner"><span>juxt*</span></div></a></li><li class="depth-1"><a href="claro.projection.html#var-leaf"><div class="inner"><span>leaf</span></div></a></li><li class="depth-1"><a href="claro.projection.html#var-let"><div class="inner"><span>let</span></div></a></li><li class="depth-1"><a href="claro.projection.html#var-levels"><div class="inner"><span>levels</span></div></a></li><li class="depth-1"><a href="claro.projection.html#var-maybe"><div class="inner"><span>maybe</span></div></a></li><li class="depth-1"><a href="claro.projection.html#var-maybe-parameters"><div class="inner"><span>maybe-parameters</span></div></a></li><li class="depth-1"><a href="claro.projection.html#var-merge"><div class="inner"><span>merge</span></div></a></li><li class="depth-1"><a href="claro.projection.html#var-merge*"><div class="inner"><span>merge*</span></div></a></li><li class="depth-1"><a href="claro.projection.html#var-parameters"><div class="inner"><span>parameters</span></div></a></li><li class="depth-1"><a href="claro.projection.html#var-prepare"><div class="inner"><span>prepare</span></div></a></li><li class="depth-1"><a href="claro.projection.html#var-remove-nil-elements"><div class="inner"><span>remove-nil-elements</span></div></a></li><li class="depth-1"><a href="claro.projection.html#var-sort-by"><div class="inner"><span>sort-by</span></div></a></li><li class="depth-1"><a href="claro.projection.html#var-transform"><div class="inner"><span>transform</span></div></a></li><li class="depth-1"><a href="claro.projection.html#var-transform-finite"><div class="inner"><span>transform-finite</span></div></a></li><li class="depth-1"><a href="claro.projection.html#var-union"><div class="inner"><span>union</span></div></a></li><li class="depth-1"><a href="claro.projection.html#var-union*"><div class="inner"><span>union*</span></div></a></li><li class="depth-1"><a href="claro.projection.html#var-unsafe"><div class="inner"><span>unsafe</span></div></a></li><li class="depth-1"><a href="claro.projection.html#var-value"><div class="inner"><span>value</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">claro.projection</h1><div class="doc"><div class="markdown"><p>Powerful tree projection functions.</p>
<p>These will allow you to convert an infinite tree of <code>Resolvable</code> values to a finite form, performing transformations, injections and selection along the way.</p>
<p>See <a href="01-projection.html">Projections</a> and <a href="02-advanced-projection.html">Advanced Projections</a> for a detailed discussion and examples.</p></div></div><div class="public anchor" id="var-alias"><h3>alias</h3><div class="usage"><code>(alias alias-key key)</code></div><div class="doc"><div class="markdown"><p>This function can be used within maps to rename/copy an existing key for further projection, e.g.:</p>
<pre><code class="clojure">{:id                          projection/leaf
 (alias :friend-id :friend)   {:id projection/leaf}
 (alias :friend-name :friend) {:name projection/leaf}}
</code></pre>
<p>This would result in a map of the following shape:</p>
<pre><code class="clojure">{:id          1
 :friend-id   {:id 2}
 :friend-name {:name "Dr. Watson"}}
</code></pre></div></div><div class="src-link"><a href="https://github.com/xsc/claro/blob/master/src/claro/projection/maps.cljc#L131">view source</a></div></div><div class="public anchor" id="var-apply"><h3>apply</h3><div class="usage"><code>(apply value template)</code></div><div class="doc"><div class="markdown"><p>Project the given value using the given template.</p></div></div><div class="src-link"><a href="https://github.com/xsc/claro/blob/master/src/claro/projection.cljc#L38">view source</a></div></div><div class="public anchor" id="var-bind"><h3>bind</h3><div class="usage"><code>(bind bind-fn template)</code></div><div class="doc"><div class="markdown"><p>A two-step projection, using a partial projection result to generate the eventual, full projection. Example:</p>
<pre><code class="clojure">(projection/bind
  (fn [{:keys [id]}]
    {:children
     [{:id        projection/leaf
       :parent-id (projection/value id)}]})
  {:id projection/leaf})
</code></pre>
<p>This will use <code>{:id projection/leaf}</code> to project the current value and pass the result to the given function – which is then expected to return the “actual” projection template for the current value.</p>
<p>This projection is useful to “remember” values in the tree.</p></div></div><div class="src-link"><a href="https://github.com/xsc/claro/blob/master/src/claro/projection/bind.cljc#L31">view source</a></div></div><div class="public anchor" id="var-case"><h3>case</h3><h4 class="added">added in 0.2.1</h4><div class="usage"><code>(case class template &amp; more)</code></div><div class="doc"><div class="markdown"><p>Dispatch on the class of a value (after resolution), applying the corresponding template.</p>
<pre><code class="clojure">(-&gt; (-&gt;Animals)
    (projection/apply
      [(projection/case
         Dolphin {:name projection/leaf, :intelligence projection/leaf}
         Zebra   {:name projection/leaf, :number-of-stripes projection/leaf}
         :else   {:name projection/leaf})])
     (engine/run!!))
;; =&gt; [{:name "Tiger"}
;;     {:name "Dolphin", :intelligence 80}
;;     {:name "Zebra", :number-of-stripes 20}]
</code></pre>
<p>By specifiying a vector of classes, e.g. <code>[Tiger Zebra]</code> you can apply the same projection to multiple kinds of resolvables.</p></div></div><div class="src-link"><a href="https://github.com/xsc/claro/blob/master/src/claro/projection/case.cljc#L115">view source</a></div></div><div class="public anchor" id="var-case-resolvable"><h3>case-resolvable</h3><h4 class="added">added in 0.2.1</h4><div class="usage"><code>(case-resolvable class template &amp; more)</code></div><div class="doc"><div class="markdown"><p>Dispatch on the class of a <code>Resolvable</code>, applying the corresponding template.</p>
<pre><code class="clojure">(-&gt; (-&gt;Animals)
    (projection/apply
      [(projection/case-resolvable
         Dolphin {:name projection/leaf, :intelligence projection/leaf}
         Zebra   {:name projection/leaf, :number-of-stripes projection/leaf}
         :else   {:name projection/leaf})])
     (engine/run!!))
;; =&gt; [{:name "Tiger"}
;;     {:name "Dolphin", :intelligence 80}
;;     {:name "Zebra", :number-of-stripes 20}]
</code></pre>
<p>By specifiying a vector of classes, e.g. <code>[Tiger Zebra]</code> you can apply the same projection to multiple kinds of resolvables.</p></div></div><div class="src-link"><a href="https://github.com/xsc/claro/blob/master/src/claro/projection/case.cljc#L90">view source</a></div></div><div class="public anchor" id="var-conditional"><h3>conditional</h3><div class="usage"><code>(conditional partial-template condition template &amp; more)</code></div><div class="doc"><div class="markdown"><p>Apply the first projection whose predicate matches the value resulting from projecting <code>partial-template</code>.</p>
<pre><code>(projection/conditional
  {:type projection/leaf}
  (comp #{:animal} :type) {:left-paw projection/leaf}
  (comp #{:human} :type)  {:left-hand projection/leaf})
</code></pre>
<p><code>:else</code> can be given to denote the default case:</p>
<pre><code class="clojure">(projection/conditional
  {:type projection/leaf}
  (comp #{:animal} :type) {:left-paw projection/leaf}
  :else                   {:left-hand projection/leaf})
</code></pre>
<p>Note that, sometimes, you can express this just as well using a <a href="claro.projection.html#var-bind">bind</a> or <a href="claro.projection.html#var-let">let</a> projection:</p>
<pre><code class="clojure">(projection/let [{:keys [type]} {:type projection/leaf}]
  (case type
    :animal {:left-paw projection/leaf}
    :human  {:left-hand projection/leaf}))
</code></pre></div></div><div class="src-link"><a href="https://github.com/xsc/claro/blob/master/src/claro/projection/conditional.cljc#L53">view source</a></div></div><div class="public anchor" id="var-conditional-union"><h3>conditional-union</h3><div class="usage"><code>(conditional-union partial-template condition template &amp; more)</code></div><div class="doc"><div class="markdown"><p>Apply and merge all projections whose predicates match the value resulting from projecting <code>partial-template</code>.</p>
<pre><code class="clojure">(projection/conditional-union
  {:type          projection/leaf
   :has-children? projection/leaf}
  (comp #{:animal} :type) {:left-paw projection/leaf}
  (comp #{:human} :type)  {:left-hand projection/leaf}
  :has-children?          {:children [{:name projection/leaf}]})
</code></pre>
<p>The matching projections have to produce maps with disjunct sets of keys.</p></div></div><div class="src-link"><a href="https://github.com/xsc/claro/blob/master/src/claro/projection/conditional.cljc#L87">view source</a></div></div><div class="public anchor" id="var-default"><h3>default</h3><div class="usage"><code>(default template default-value)</code></div><div class="doc"><div class="markdown"><p>Apply the given projection to any non-nil value or the given default.</p>
<pre><code class="clojure">(projection/default {:name projection/leaf} unknown-person)
</code></pre>
<p>Note that this will cause the default value to be injected into a result map even if the respective key is missing.</p></div></div><div class="src-link"><a href="https://github.com/xsc/claro/blob/master/src/claro/projection/maybe.cljc#L56">view source</a></div></div><div class="public anchor" id="var-extract"><h3>extract</h3><div class="usage"><code>(extract template k)</code><code>(extract k)</code></div><div class="doc"><div class="markdown"><p>Extract a subtree/leaf located under the given key.</p>
<pre><code class="clojure">(-&gt; (-&gt;Person 1)
    (projection/apply (extract :name))
    (engine/run!!))
;; =&gt; "Sherlock"
</code></pre>
<p>For non-leaf values, a template can be given that will be applied before extraction.</p></div></div><div class="src-link"><a href="https://github.com/xsc/claro/blob/master/src/claro/projection/aux.cljc#L23">view source</a></div></div><div class="public anchor" id="var-extract-in"><h3>extract-in</h3><h4 class="added">added in 0.2.13</h4><div class="usage"><code>(extract-in template ks)</code><code>(extract-in ks)</code></div><div class="doc"><div class="markdown"><p>Extract a subtree/leaf located under the given path.</p>
<pre><code class="clojure">(-&gt; {:sherlock (-&gt;Person 1)}
    (projection/apply (extract-in [:sherlock :name]))
    (engine/run!!))
;; =&gt; "Sherlock"
</code></pre>
<p>For non-leaf values, a template can be given that will be applied before extraction.</p></div></div><div class="src-link"><a href="https://github.com/xsc/claro/blob/master/src/claro/projection/aux.cljc#L6">view source</a></div></div><div class="public anchor" id="var-finite-value"><h3>finite-value</h3><h4 class="added">added in 0.2.3</h4><div class="usage"><code>(finite-value value)</code></div><div class="doc"><div class="markdown"><p>Like <a href="claro.projection.html#var-value">value</a> but will not apply any further projection to the given value. This means that you can use this to inject arbitrary (but finite!) subtrees into your data.</p>
<p>(If you still give a potentially infinite resolvable, you’ll hit claro’s resolution limits.)</p></div></div><div class="src-link"><a href="https://github.com/xsc/claro/blob/master/src/claro/projection/value.cljc#L59">view source</a></div></div><div class="public anchor" id="var-juxt"><h3>juxt</h3><h4 class="added">added in 0.2.13</h4><div class="usage"><code>(juxt &amp; templates)</code></div><div class="doc"><div class="markdown"><p>Creates a vector with results of projecting the current value with each of the given <code>templates</code> (maintaining order):</p>
<pre><code class="clojure">(projection/juxt
  (projection/extract :id)
  (projection/extract :name))
</code></pre>
<p>This, for example, will convert a map with <code>:id</code> and <code>:name</code> keys to a tuple.</p></div></div><div class="src-link"><a href="https://github.com/xsc/claro/blob/master/src/claro/projection/juxt.cljc#L43">view source</a></div></div><div class="public anchor" id="var-juxt*"><h3>juxt*</h3><h4 class="added">added in 0.2.13</h4><div class="usage"><code>(juxt* templates)</code></div><div class="doc"><div class="markdown"><p>Creates a vector with results of projecting the current value with each of the given <code>templates</code> (maintaining order):</p>
<pre><code class="clojure">(projection/juxt*
  [(projection/extract :id)
   (projection/extract :name)])
</code></pre>
<p>This, for example, will convert a map with <code>:id</code> and <code>:name</code> keys to a tuple.</p></div></div><div class="src-link"><a href="https://github.com/xsc/claro/blob/master/src/claro/projection/juxt.cljc#L27">view source</a></div></div><div class="public anchor" id="var-leaf"><h3>leaf</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>Projection template for leaf values (equivalent to <code>nil</code> but preferable since more explicit).</p></div></div><div class="src-link"><a href="https://github.com/xsc/claro/blob/master/src/claro/projection/objects.cljc#L28">view source</a></div></div><div class="public anchor" id="var-let"><h3>let</h3><h4 class="type">macro</h4><div class="usage"><code>(let bindings &amp; body)</code></div><div class="doc"><div class="markdown"><p>Syntactic sugar for the <a href="claro.projection.html#var-bind">bind</a> projection.</p>
<pre><code class="clojure">(projection/let [{:keys [id]} {:id projection/leaf}]
  {:children [{:id        projection/leaf
               :parent-id (projection/value id)}]})
</code></pre>
<p>is equal to:</p>
<pre><code class="clojure">(projection/bind
  (fn [{:keys [id]}]
    {:children [{:id        projection/leaf
                 :parent-id (projection/value id)}]})
  {:id projection/leaf})
</code></pre>
<p>Multiple binding templates are supported (although you’ll usually want to only use one):</p>
<pre><code class="clojure">(projection/let [{:keys [id]}   {:id projection/leaf}
                 {:keys [name]} {:name projection/leaf}]
  ...)
</code></pre></div></div><div class="src-link"><a href="https://github.com/xsc/claro/blob/master/src/claro/projection/bind.cljc#L54">view source</a></div></div><div class="public anchor" id="var-levels"><h3>levels</h3><div class="usage"><code>(levels n)</code></div><div class="doc"><div class="markdown"><p>Generate Projection template representing the first <code>n</code> levels of a value. Leafs up to the given level will be maintained.</p>
<p>E.g. for the following value:</p>
<pre><code>{:a 0
 :b {:c 1}
 :d {:e [{:f 2}]}}
</code></pre>
<p>Result for <code>n</code> == 1:</p>
<pre><code>{:a 0, :b {}, :d {}}
</code></pre>
<p>Result for <code>n</code> == 2;</p>
<pre><code>{:a 0, :b {:c 1}, :d {:e []}}
</code></pre>
<p>For <code>n</code> &gt;= 3, the full value will be returned.</p></div></div><div class="src-link"><a href="https://github.com/xsc/claro/blob/master/src/claro/projection/level.cljc#L47">view source</a></div></div><div class="public anchor" id="var-maybe"><h3>maybe</h3><div class="usage"><code>(maybe template)</code></div><div class="doc"><div class="markdown"><p>Apply projection template if the value is not <code>nil</code>, otherwise just keep the <code>nil</code>.</p>
<pre><code class="clojure">(projection/maybe {:name projection/leaf})
</code></pre>
<p>Note that this will cause a <code>nil</code> to be injected into a result map even if the respective key is missing.</p></div></div><div class="src-link"><a href="https://github.com/xsc/claro/blob/master/src/claro/projection/maybe.cljc#L20">view source</a></div></div><div class="public anchor" id="var-maybe-parameters"><h3>maybe-parameters</h3><h4 class="added">added in 0.2.18</h4><div class="usage"><code>(maybe-parameters params rest-template)</code></div><div class="doc"><div class="markdown"><p>Like <a href="claro.projection.html#var-parameters">parameters</a> but will ignore <code>nil</code> values.</p></div></div><div class="src-link"><a href="https://github.com/xsc/claro/blob/master/src/claro/projection/parameters.cljc#L111">view source</a></div></div><div class="public anchor" id="var-merge"><h3>merge</h3><h4 class="added">added in 0.2.5</h4><div class="usage"><code>(merge &amp; templates)</code></div><div class="doc"><div class="markdown"><p>Like <a href="claro.projection.html#var-union">union</a> but will merge overlapping keys like <code>clojure.core/merge</code>.</p></div></div><div class="src-link"><a href="https://github.com/xsc/claro/blob/master/src/claro/projection/union.cljc#L139">view source</a></div></div><div class="public anchor" id="var-merge*"><h3>merge*</h3><h4 class="added">added in 0.2.5</h4><div class="usage"><code>(merge* templates)</code></div><div class="doc"><div class="markdown"><p>Like <a href="claro.projection.html#var-union*">union*</a> but will merge overlapping keys like <code>clojure.core/merge</code>.</p></div></div><div class="src-link"><a href="https://github.com/xsc/claro/blob/master/src/claro/projection/union.cljc#L131">view source</a></div></div><div class="public anchor" id="var-parameters"><h3>parameters</h3><div class="usage"><code>(parameters params rest-template)</code></div><div class="doc"><div class="markdown"><p>Set some fields within a Resolvable record before resolution. Note that:</p>
<ul>
  <li>You can only set fields that currently have the value <code>nil</code> (i.e. no  overriding of already set fields).</li>
  <li>You can only set fields the record already contains (i.e. records have to  explicitly contain even optional parameter fields).</li>
</ul>
<p>These restrictions are intended to make resolution more predictable. Note that you can always use <code>prepare</code> directly to perform arbitrary injections.</p></div></div><div class="src-link"><a href="https://github.com/xsc/claro/blob/master/src/claro/projection/parameters.cljc#L77">view source</a></div></div><div class="public anchor" id="var-prepare"><h3>prepare</h3><div class="usage"><code>(prepare f rest-template)</code></div><div class="doc"><div class="markdown"><p>A projection applying a transformation function to a value (before resolution!), with <code>rest-template</code> being used to further project the resulting value.</p></div></div><div class="src-link"><a href="https://github.com/xsc/claro/blob/master/src/claro/projection/transform.cljc#L26">view source</a></div></div><div class="public anchor" id="var-remove-nil-elements"><h3>remove-nil-elements</h3><div class="usage"><code>(remove-nil-elements &amp; [template])</code></div><div class="doc"><div class="markdown"><p>A projection to remove all <code>nil</code> elements from a seq, before applying the given <code>template</code> to it. If no <code>template</code> is given, the seq without <code>nil</code> values will be returned directly (and needs to have another projection applied if infinite subtrees are possible).</p></div></div><div class="src-link"><a href="https://github.com/xsc/claro/blob/master/src/claro/projection/remove_nil.clj#L61">view source</a></div></div><div class="public anchor" id="var-sort-by"><h3>sort-by</h3><h4 class="added">added in 0.2.19</h4><div class="usage"><code>(sort-by sort-template)</code><code>(sort-by sort-template output-template)</code></div><div class="doc"><div class="markdown"><p>A projection sorting the sequence that’s currently being resolved. <code>sort-template</code> is applied to each element of the sequence to generate a value to sort by, while `output-template´ is used to further project the resulting sorted sequence.</p>
<pre><code class="clojure">(-&gt; [{:index 3, :value 'third}
     {:index 1, :value 'first}
     {:index 2, :value 'second}]
    (projection/apply
      (projection/sort-by
        (projection/extract :index)
        [{:value projection/leaf}]))
    (engine/run!!))
;; =&gt; [{:value 'first}, {:value 'second}, {:value 'third}]
</code></pre>
<p>If no <code>output-template</code> is given, the resulting tree may not be infinite (or a further projection has to be applied externally).</p></div></div><div class="src-link"><a href="https://github.com/xsc/claro/blob/master/src/claro/projection/sort.cljc#L34">view source</a></div></div><div class="public anchor" id="var-transform"><h3>transform</h3><div class="usage"><code>(transform f input-template)</code><code>(transform f input-template output-template)</code></div><div class="doc"><div class="markdown"><p>A projection applying a transformation function to a fully resolved value. <code>input-template</code> is used to project the initial value, <code>output-template</code> will be used to further project the resulting value.</p>
<p>For example, to extract the <code>:name</code> key from a seq of maps:</p>
<pre><code class="clojure">(-&gt; [{:name "Zebra"}, {:name "Tiger"}]
    (projection/apply
      [(projection/transform :name {:name projection/leaf} projection/leaf)])
    (engine/run!!))
;; =&gt; ["Zebra" "Tiger"]
</code></pre>
<p>If no <code>output-template</code> is given, you <em>have</em> to apply projections to potentially infinite subtrees within the transformation function.</p>
<p>If the transformation won’t introduce any new resolvables, <a href="claro.projection.html#var-transform-finite">transform-finite</a> should be preferred due to its better performance with deeply nested trees.</p></div></div><div class="src-link"><a href="https://github.com/xsc/claro/blob/master/src/claro/projection/transform.cljc#L51">view source</a></div></div><div class="public anchor" id="var-transform-finite"><h3>transform-finite</h3><h4 class="added">added in 0.2.15</h4><div class="usage"><code>(transform-finite f input-template)</code></div><div class="doc"><div class="markdown"><p>Like <a href="claro.projection.html#var-transform">transform</a> but assuming that <code>f</code> produces a finite value, i.e. one without any further resolvables.</p>
<p>For transformations on deeply nested structures this will perform better than <a href="claro.projection.html#var-transform">transform</a> since it avoids re-inspection of the tree.</p></div></div><div class="src-link"><a href="https://github.com/xsc/claro/blob/master/src/claro/projection/transform.cljc#L92">view source</a></div></div><div class="public anchor" id="var-union"><h3>union</h3><div class="usage"><code>(union &amp; templates)</code></div><div class="doc"><div class="markdown"><p>Syntactic sugar for <a href="claro.projection.html#var-union*">union*</a> allowing for projections-to-merge to be given as single parameters:</p>
<pre><code class="clojure">(projection/union
  {:id projection/leaf}
  (projection/case-resolvable
    Zebra   {:number-of-stripes projection/leaf}
    Dolphin {:intelligence projection/leaf}
    :else   {}))
</code></pre>
<p>Note that the the templates have to produce maps with disjunct sets of keys.</p></div></div><div class="src-link"><a href="https://github.com/xsc/claro/blob/master/src/claro/projection/union.cljc#L114">view source</a></div></div><div class="public anchor" id="var-union*"><h3>union*</h3><div class="usage"><code>(union* templates)</code></div><div class="doc"><div class="markdown"><p>Apply all projection templates to the value, merging them together into a final value.</p>
<pre><code class="clojure">(projection/union
  [{:id projection/leaf}
   (projection/case-resolvable
     Zebra   {:number-of-stripes projection/leaf}
     Dolphin {:intelligence projection/leaf}
     :else   {})])
</code></pre>
<p>Note that the the templates have to produce maps with disjunct sets of keys.</p></div></div><div class="src-link"><a href="https://github.com/xsc/claro/blob/master/src/claro/projection/union.cljc#L84">view source</a></div></div><div class="public anchor" id="var-unsafe"><h3>unsafe</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>Projection template for any kind of value. If this is used in places where infinite subtrees can occur, engine executions <em>will</em> run forever or exceed the maximum resolution cost.</p></div></div><div class="src-link"><a href="https://github.com/xsc/claro/blob/master/src/claro/projection/objects.cljc#L43">view source</a></div></div><div class="public anchor" id="var-value"><h3>value</h3><div class="usage"><code>(value value &amp; [template])</code></div><div class="doc"><div class="markdown"><p>A projection that replaces any value it encounters with the given one. <code>template</code> will be used for further projection, if given, otherwise <a href="claro.projection.html#var-leaf">leaf</a> is used.</p>
<p>Note that this projection can be used to inject values into a map, i.e. the result of</p>
<pre><code class="clojure">{:id       projection/leaf
 :name     projection/leaf
 :visible? (projection/value true)}
</code></pre>
<p>will always contain a key <code>:visible?</code> with value <code>true</code> – even if the original map had no such key.</p></div></div><div class="src-link"><a href="https://github.com/xsc/claro/blob/master/src/claro/projection/value.cljc#L40">view source</a></div></div></div></body></html>