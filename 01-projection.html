<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>Projections</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="highlight/solarized-light.css" /><script type="text/javascript" src="highlight/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a> with <a href="https://github.com/xsc/codox-theme-rdash">RDash UI</a> theme</h2><h1><a href="index.html"><span class="project-title"><span class="project-name">claro</span> <span class="project-version">0.2.20</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1 "><a href="00-basics.html"><div class="inner"><span>Basic Resolution</span></div></a></li><li class="depth-1  current"><a href="01-projection.html"><div class="inner"><span>Projections</span></div></a></li><li class="depth-1 "><a href="02-advanced-projection.html"><div class="inner"><span>Advanced Projections</span></div></a></li><li class="depth-1 "><a href="03-engine.html"><div class="inner"><span>Engine</span></div></a></li><li class="depth-1 "><a href="04-testing-and-debugging.html"><div class="inner"><span>Testing &amp; Debugging</span></div></a></li><li class="depth-1 "><a href="99-notes.html"><div class="inner"><span>Implementation Notes</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>claro</span></div></div></li><li class="depth-2"><a href="claro.data.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>data</span></div></a></li><li class="depth-3"><a href="claro.data.ops.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>ops</span></div></a></li><li class="depth-2"><a href="claro.engine.html"><div class="inner"><span class="tree" style="top: -52px;"><span class="top" style="height: 61px;"></span><span class="bottom"></span></span><span>engine</span></div></a></li><li class="depth-3 branch"><a href="claro.engine.adapter.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>adapter</span></div></a></li><li class="depth-3"><a href="claro.engine.selector.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>selector</span></div></a></li><li class="depth-2"><div class="no-link"><div class="inner"><span class="tree" style="top: -83px;"><span class="top" style="height: 92px;"></span><span class="bottom"></span></span><span>middleware</span></div></div></li><li class="depth-3 branch"><a href="claro.middleware.cache.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>cache</span></div></a></li><li class="depth-3 branch"><a href="claro.middleware.deferred.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>deferred</span></div></a></li><li class="depth-3 branch"><a href="claro.middleware.intercept.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>intercept</span></div></a></li><li class="depth-3 branch"><a href="claro.middleware.mock.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>mock</span></div></a></li><li class="depth-3 branch"><a href="claro.middleware.observe.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>observe</span></div></a></li><li class="depth-3"><a href="claro.middleware.transform.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>transform</span></div></a></li><li class="depth-2"><a href="claro.projection.html"><div class="inner"><span class="tree" style="top: -207px;"><span class="top" style="height: 216px;"></span><span class="bottom"></span></span><span>projection</span></div></a></li></ul></div><div class="document" id="content"><div class="doc"><div class="markdown"><h1><a href="#projections" name="projections"></a>Projections</h1>
<p>If you’ve read about claro <code>Resolvable</code> values you might have noticed that there is nothing preventing you from creating infinite trees or cycles between different resolvable types.</p>
<p>For example, a <code>Person</code> could have a list of friends. And why, I ask you, would they themselves be represented as anything other than <code>Person</code> records?</p>
<pre><code class="clojure">(declare -&gt;FriendsOf)

(defrecord Person [id]
  data/Resolvable
  (resolve! [_ env]
    (d/future
      (-&gt; (fetch-person! (:db env) id)
          (assoc :friends (-&gt;FriendsOf id))))))

(defrecord FriendsOf [id]
  data/Resolvable
  (resolve! [_ env]
    (d/future
      (-&gt;&gt; (fetch-friend-ids! (:db env) id)
           (map -&gt;Person)))))
</code></pre>
<p>Of course, this explodes horribly when resolving (after taking an equally horrible amount of time, nonetheless):</p>
<pre><code class="clojure">(engine/run!! (-&gt;Person 1))
;; =&gt; IllegalStateException: resolution has exceeded maximum batch size
</code></pre>
<p>But claro is built around infinite trees. It provides powerful facilites of dealing with infinitely nested data – the most elegant of which are <em>projections</em>.</p>
<pre><code class="clojure">(require '[claro.projection :as projection])
</code></pre>
<h3><a href="#overview" name="overview"></a>Overview</h3>
<p>A projection describes how to convert an infinite tree into a finite one. That’s about it, really, so let’s write our first projection:</p>
<pre><code class="clojure">(def base-person
  {:id   projection/leaf
   :name projection/leaf})
</code></pre>
<p>This basically says: “Out of all the available fields, take <code>:id</code> and <code>:name</code> and expect them to be leaves of the tree (i.e. not a collection).” Let’s try it out:</p>
<pre><code class="clojure">(engine/run!!
  (projection/apply (-&gt;Person 1) base-person))
;; =&gt; {:id 1, :name "Sherlock Holmes"}
</code></pre>
<p>We threw away the list of <code>:friends</code> provided to us by <code>Person</code> since we never mentioned it. Let’s see who’s in there by extending our base projection:</p>
<pre><code class="clojure">(def person-with-friends
  {:id      projection/leaf
   :name    projection/leaf
   :friends [{:id   projection/leaf
              :name projection/leaf}]})

(engine/run!!
  (projection/apply (-&gt;Person 1) person-with-friends))
;; =&gt; {:id 1
;;     :name "Sherlock Holmes"
;;     :friends [{:id 2, :name "John Watson"}
;;               {:id 3, :name "Miss Hudson"}]}
</code></pre>
<p>As you can see, projections can be nested. And by putting them inside a vector we apply them to every element of a seq.</p>
<h3><a href="#interlude" name="interlude"></a>Interlude</h3>
<p><strong>Projections force you to think about the shape of the data you want to retrieve. They are query and schema at once.</strong></p>
<p>Most importantly, they move any transformation logic away from the actual data access. This let’s you naively create rich trees of entities – any subtree will only be retrieved if someone asks for it.</p>
<p>And this leads to different views on the same entity being represented as projections. You don’t need the high-quality image URL on a list page? Remove it from the projection. You need the new view counter to be displayed on all detail pages? Well, just add it.</p>
<p>This doesn’t mean you can just be careless, of course. Writing flexibly reusable projections is just as much of a challenge as writing reusable code in general.</p>
<h3><a href="#more-projections" name="more-projections"></a>More Projections</h3>
<h4><a href="#union" name="union"></a>Union</h4>
<p>Speaking of reusability, it can be useful to merge the results of multiple projections:</p>
<pre><code class="clojure">(def base-person
  {:id   projection/leaf
   :name projection/leaf})

(def friend-list
  {:friends [base-person]})

(def person-with-friends
  (projection/union
    [base-person
     friend-list]))
</code></pre>
<blockquote>
  <p><strong>Note:</strong> You might be tempted to use <code>merge</code> in these cases. Don’t, since it only works with plain-map projections and you might want to use others sometime in the future.</p>
</blockquote>
<h4><a href="#parameterisation" name="parameterisation"></a>Parameterisation</h4>
<p>Let’s say it should be possible to influence how many of a person’s friends are returned. For this, we add a field to the respective record:</p>
<pre><code class="clojure">(defrecord FriendsOf [id limit offset]
  data/Resolvable
  (resolve! [_ env]
    (d/future
      (-&gt;&gt; (fetch-friend-ids! (:db env) id (or limit 10) (or offset 0))
           (map -&gt;Person)))))
</code></pre>
<blockquote>
  <p><strong>Note:</strong> If you have a list of entities somewhere, always make it possible to only return a subset (and ideally only return a limited number of items per default). Otherwise, long lists will undoubtedly bring your application to its knees.</p>
</blockquote>
<p>We can now craft a special projection, only retrieving the names of the first five friends of a given person:</p>
<pre><code class="clojure">(def person-with-five-friends
  {:id      projection/leaf
   :name    projection/leaf
   :friends (projection/parameters {:limit 5} [{:name projection/leaf}])})
</code></pre>
<p><code>parameters</code> takes two arguments: the parameters to inject, as well as <em>another</em> projection that will be applied to the resulting subtree. See the documentation of <a href="claro.projection.html#var-parameters">parameters</a> for further details.</p>
<h4><a href="#aliases" name="aliases"></a>Aliases</h4>
<p>To rename a field you can use the <a href="claro.projection.html#var-alias">alias</a> projection:</p>
<pre><code class="clojure">{:id                                   projection/leaf
 (projection/alias :person-name :name) projection/leaf}
</code></pre>
<p>This is especially useful if you want to apply multiple different projections to the same subtree, e.g. to inject a series of parameters into a field. For example, we could introduce a flag checking friend status to our <code>Person</code> records:</p>
<pre><code class="clojure">(defrecord Friend? [person-id friend-id]
  data/Resolvable
  (resolve! [_ env]
    ...))

(defrecord Person [id]
  data/Resolvable
  (resolve! [_ env]
    (d/future
      (merge
        (fetch-person! (:db env) id)
        {:friend-of? (-&gt;Friend? nil id)
         :friends    (-&gt;FriendsOf id)}))))
</code></pre>
<p>If we want to check whether a certain person is friends with two specific users we can use <a href="claro.projection.html#var-alias">alias</a> and <a href="claro.projection.html#var-parameters">parameters</a> to generate a result:</p>
<pre><code class="clojure">(defn- friend-of?
  [alias-key person-id]
  {(projection/alias alias-key :friend-of?)
   (projection/parameters
     {:person-id person-id}
     {:name projection/leaf})))

(def person-with-certain-friends
  (projection/union
    [{:id projection/leaf
      :name projection/leaf}
     (friend-of? :friend-of-sherlock? 1)
     (friend-of? :friend-of-watson? 2)))
</code></pre>
<p>Applying this projection to a <code>Person</code> will produce a map akin to:</p>
<pre><code class="clojure">{:id 3
 :name "Miss Hudson"
 :friend-of-sherlock? true
 :friend-of-watson? true}
</code></pre>
<h4><a href="#missing-values" name="missing-values"></a>Missing Values</h4>
<p>Sometimes, fields can be <code>nil</code> which would cause any non-leaf projection to panic. Using <a href="claro.projection.html#var-maybe">maybe</a> we can handle this case, e.g. if we don’t know whether a <code>Person</code> actually exists:</p>
<pre><code class="clojure">(projection/maybe {:name projection/leaf})
</code></pre>
<p>In the same vein, we might want to return a <a href="claro.projection.html#var-default">default</a> value if we couldn’t retrieve a real one:</p>
<pre><code class="clojure">(projection/default {:name projection/leaf} unknown-person)
</code></pre>
<p>This will apply the given projection either to any non-<code>nil</code> value or to <code>unknown-person</code>.</p>
<h4><a href="#constant-values" name="constant-values"></a>Constant Values</h4>
<p>It might happen that you want to inject a value into the tree. For this, you can use the <a href="claro.projection.html#var-value">value</a> projection:</p>
<pre><code class="clojure">{:id   projection/leaf
 :role (projection/value :admin)}
</code></pre>
<p>If you want to inject non-leaf values – like another resolvable – you’ll need to supply a projection to apply on it, e.g.:</p>
<pre><code class="clojure">{:id    projection/leaf
 :roles (projection/value (-&gt;Roles) [projection/leaf])}
</code></pre>
<p>If you want to inject a more complex value but you’re absolutely sure it does not resolve infinitely, you can use <a href="claro.projection.html#var-finite-value">finite-value</a>.</p></div></div></div></body></html>