<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>Advanced Projections</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="highlight/solarized-light.css" /><script type="text/javascript" src="highlight/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a> with <a href="https://github.com/xsc/codox-theme-rdash">RDash UI</a> theme</h2><h1><a href="index.html"><span class="project-title"><span class="project-name">claro</span> <span class="project-version">0.2.20</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1 "><a href="00-basics.html"><div class="inner"><span>Basic Resolution</span></div></a></li><li class="depth-1 "><a href="01-projection.html"><div class="inner"><span>Projections</span></div></a></li><li class="depth-1  current"><a href="02-advanced-projection.html"><div class="inner"><span>Advanced Projections</span></div></a></li><li class="depth-1 "><a href="03-engine.html"><div class="inner"><span>Engine</span></div></a></li><li class="depth-1 "><a href="04-testing-and-debugging.html"><div class="inner"><span>Testing &amp; Debugging</span></div></a></li><li class="depth-1 "><a href="99-notes.html"><div class="inner"><span>Implementation Notes</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>claro</span></div></div></li><li class="depth-2"><a href="claro.data.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>data</span></div></a></li><li class="depth-3"><a href="claro.data.ops.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>ops</span></div></a></li><li class="depth-2"><a href="claro.engine.html"><div class="inner"><span class="tree" style="top: -52px;"><span class="top" style="height: 61px;"></span><span class="bottom"></span></span><span>engine</span></div></a></li><li class="depth-3 branch"><a href="claro.engine.adapter.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>adapter</span></div></a></li><li class="depth-3"><a href="claro.engine.selector.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>selector</span></div></a></li><li class="depth-2"><div class="no-link"><div class="inner"><span class="tree" style="top: -83px;"><span class="top" style="height: 92px;"></span><span class="bottom"></span></span><span>middleware</span></div></div></li><li class="depth-3 branch"><a href="claro.middleware.cache.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>cache</span></div></a></li><li class="depth-3 branch"><a href="claro.middleware.deferred.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>deferred</span></div></a></li><li class="depth-3 branch"><a href="claro.middleware.intercept.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>intercept</span></div></a></li><li class="depth-3 branch"><a href="claro.middleware.mock.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>mock</span></div></a></li><li class="depth-3 branch"><a href="claro.middleware.observe.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>observe</span></div></a></li><li class="depth-3"><a href="claro.middleware.transform.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>transform</span></div></a></li><li class="depth-2"><a href="claro.projection.html"><div class="inner"><span class="tree" style="top: -207px;"><span class="top" style="height: 216px;"></span><span class="bottom"></span></span><span>projection</span></div></a></li></ul></div><div class="document" id="content"><div class="doc"><div class="markdown"><h1><a href="#advanced-projections" name="advanced-projections"></a>Advanced Projections</h1>
<p>Sometimes, you need a bit more flexibility than the <a href="01-projection.html">basic projections</a> can offer – and claro can provide that by allowing arbitrary, and even conditional, transformations of your data.</p>
<h3><a href="#dispatch-on-resolvable-or-result-class" name="dispatch-on-resolvable-or-result-class"></a>Dispatch on Resolvable or Result Class</h3>
<p>There might be cases where you expect different kinds of <code>Resolvable</code> values to appear at a certain position. For example, we might want to model a series of different animals:</p>
<pre><code class="clojure">(defrecord Tiger [id]
  data/Resolvable
  (resolve! [_ _]
    (d/future
      {:id                id
       :name              "Tiger"
       :number-of-stripes (* id 4)})))

(defrecord Zebra [id]
  data/Resolvable
  (resolve! [_ _]
    (d/future
      {:id                id
       :name              "Zebra"
       :number-of-stripes (* id 4)})))

(defrecord Dolphin [id]
  data/Resolvable
  (resolve! [_ _]
    (d/future
      {:id                id
       :name              "Dolphin"
       :intelligence      (* id 40)})))
</code></pre>
<p>Assuming we have a mixed seq of these animal <code>Resolvable</code> values, we certainly can easily create a projection to retrieve <code>:id</code> and <code>:name</code> – but how do we handle the animal specific fields like <code>:number-of-stripes</code> and <code>:intelligence</code>?</p>
<p><a href="claro.projection.html#var-case-resolvable">case-resolvable</a> dispatches on the <code>Resolvable</code> class, so we could write something along the lines of:</p>
<pre><code class="clojure">(def animal
  (projection/case-resolvable
    Zebra
    {:name              projection/leaf
     :number-of-stripes projection/leaf}
    Dolphin
    {:name         projection/leaf
     :intelligence projection/leaf}
    :else
    {:name projection/leaf}))
</code></pre>
<blockquote>
  <p><strong>Note:</strong> Multiple options to dispatch on can be given by supplying a vector (e.g. <code>[Tiger Zebra]</code>) instead of just a single class.</p>
</blockquote>
<p>Application is done as usual, retrieving different fields for different animals:</p>
<pre><code class="clojure">(-&gt; [(-&gt;Tiger 1) (-&gt;Dolphin 2) (-&gt;Zebra 5)]
    (projection/apply [animal])
    (engine/run!!))
;; =&gt; [{:name "Tiger"}
;;     {:name "Dolphin", :intelligence 80}
;;     {:name "Zebra", :number-of-stripes 20}]
</code></pre>
<p>Similarly, you can use <a href="claro.projection.html#var-case">case</a> to dispatch on the class of the result, i.e. <em>after resolution</em>.</p>
<h3><a href="#dispatch-on-partial-result" name="dispatch-on-partial-result"></a>Dispatch on Partial Result</h3>
<p>Let’s keep our animals, but now let’s assume that they are not represented by different resolvables classes but can be identified using a <code>:type</code> key within the result:</p>
<pre><code class="clojure">(defrecord Animal [id]
  data/Resolvable
  (resolve! [_ _]
    (d/future
      (case (mod id 3)
        0 {:type :tiger, :name "Tiger", :number-of-stripes (* id 4)}
        1 {:type :zebra, :name "Zebra", :number-of-stripes (* id 4)}
        2 {:type :dolphin, :name "Dolphin", :intelligence (* id 40)}))))
</code></pre>
<p>To handle this we have to retrieve the <code>:type</code> key first and decide on what projection to <em>actually</em> use based on its value. Enter the <a href="claro.projection.html#var-conditional">conditional</a> projection:</p>
<pre><code class="clojure">(def animal
  (projection/conditional
    {:type projection/leaf}
    (comp #{:zebra} :type) {:name projection/leaf, :number-of-stripes projection/leaf}
    (comp #{:dolphin} :type) {:name projection/leaf, :intelligence projection/leaf}
    :else {:name projection/leaf}))
</code></pre>
<p>What happens here is that first we project any given element using <code>{:type
projection/leaf}</code> whose result will then be used to find a matching predicate. The corresponding projection is then re-applied to the initial element.</p>
<pre><code class="clojure">(-&gt; [(-&gt;Animal 1) (-&gt;Animal 2) (-&gt;Animal 3)]
    (projection/apply [animal])
    (engine/run!!))
;; =&gt; [{:name "Zebra", :number-of-stripes 4}
;;     {:name "Dolphin", :intelligence 80}
;;     {:name "Tiger"}]
</code></pre>
<blockquote>
  <p><strong>Note:</strong> Don’t forget the vector around the <code>(projection/conditional ...)</code> form – after all we want to apply it to each element.</p>
</blockquote>
<h3><a href="#arbitrary-transformation" name="arbitrary-transformation"></a>Arbitrary Transformation</h3>
<p>If you need to change the structure of your data (e.g. extracting keys, merging subtrees, …) you can use <a href="claro.data.html#var-transform">transform</a>.</p>
<pre><code class="clojure">(def sum-counts
  (projection/transform
    #(apply + (map :count %))
    [{:count projection/leaf}]))
</code></pre>
<p>Optionally, you can supply an output template, that will be applied to the transformed value:</p>
<pre><code class="clojure">(def sum-counts
  (projection/transform
    #(apply + (map :count %))
    [{:count projection/leaf}]
    projection/leaf))
</code></pre>
<p>As expected, this takes a seq of maps with at least the <code>:count</code> key and produces a single leaf value:</p>
<pre><code class="clojure">(-&gt; [{:type :zebra, :count 10}, {:type :dolphin, :count 5}]
    (projection/apply sum-counts)
    (engine/run!!))
;; =&gt; 15
</code></pre>
<h3><a href="#dependent-projections" name="dependent-projections"></a>Dependent Projections</h3>
<p>The above transformation and dispatch mechanisms could be seen – in one way or another – as special cases of a more generic approach:</p>
<ol>
  <li>Use an initial projection to generate a partial result.</li>
  <li>Use the partial result to generate a new projection.</li>
  <li>Apply the new projection to the initial value.</li>
</ol>
<p>Consider the following example where each <code>Person</code> has a list of followers, again <code>Person</code> values.</p>
<pre><code class="clojure">(declare -&gt;Person)

(defrecord Person [id]
  data/Resolvable
  (resolve! [_ _]
    (d/future
      {:id id, :followers (map -&gt;Person (range (inc id) (+ id 15) 3))})))
</code></pre>
<p>A valid question here could be: “Does the person in question follow their followers back?” Let’s answer it by firstly specifying what “X follows Y” means – which is clearly that their IDs have the same last digit:</p>
<pre><code class="clojure">(defrecord IsFollowing [person-id follower-id]
  data/Resolvable
  (resolve! [_ _]
    (= (mod person-id 10) (mod follower-id 10))))
</code></pre>
<p>Now, we can adjust any <code>Person</code> projection to inject an <code>IsFollowing</code> record into the person map, describing if a given <code>person-id</code> is following them.</p>
<pre><code class="clojure">(defn add-followed-by
  [template k person-id]
  (projection/let [{:keys [id]} {:id projection/leaf}]
    (projection/union
      {k (projection/value (-&gt;IsFollowing id person-id))}
      template)))
</code></pre>
<blockquote>
  <p><strong>Remember:</strong> <a href="claro.projection.html#var-value">value</a> can be used to inject/override subtrees.</p>
</blockquote>
<p>All that remains is to remember the ID of the top-level <code>Person</code> and use it to generate our concrete <code>IsFollowing</code> injection:</p>
<pre><code class="clojure">(def person-with-followers
  (projection/let [{:keys [id]} {:id projection/leaf}]
    {:id projection/leaf
     :followers [(-&gt; {:id projection/leaf}
                     (add-followed-by :followed-by-parent? id))]}))
</code></pre>
<p>And the projected result will finally answer our question:</p>
<pre><code class="clojure">(-&gt; (-&gt;Person 1)
    (projection/apply person-with-followers)
    (engine/run!!))
;; =&gt; {:id 1
;;     :followers ({:id 2,  :followed-by-parent? false}
;;                 {:id 5,  :followed-by-parent? false}
;;                 {:id 8,  :followed-by-parent? false}
;;                 {:id 11, :followed-by-parent? true}
;;                 {:id 14, :followed-by-parent? false})}
</code></pre>
<blockquote>
  <p><strong>Note:</strong> In this case one might also think about offering <code>:followed-by?</code> as a <code>Person</code> property and using <a href="claro.projection.html#var-parameters">parameters</a> to inject the top-level <code>person-id</code> into each follower.</p>
</blockquote></div></div></div></body></html>