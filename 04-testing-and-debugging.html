<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>Testing &amp; Debugging</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="highlight/solarized-light.css" /><script type="text/javascript" src="highlight/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a> with <a href="https://github.com/xsc/codox-theme-rdash">RDash UI</a> theme</h2><h1><a href="index.html"><span class="project-title"><span class="project-name">claro</span> <span class="project-version">0.2.20</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1 "><a href="00-basics.html"><div class="inner"><span>Basic Resolution</span></div></a></li><li class="depth-1 "><a href="01-projection.html"><div class="inner"><span>Projections</span></div></a></li><li class="depth-1 "><a href="02-advanced-projection.html"><div class="inner"><span>Advanced Projections</span></div></a></li><li class="depth-1 "><a href="03-engine.html"><div class="inner"><span>Engine</span></div></a></li><li class="depth-1  current"><a href="04-testing-and-debugging.html"><div class="inner"><span>Testing &amp; Debugging</span></div></a></li><li class="depth-1 "><a href="99-notes.html"><div class="inner"><span>Implementation Notes</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>claro</span></div></div></li><li class="depth-2"><a href="claro.data.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>data</span></div></a></li><li class="depth-3"><a href="claro.data.ops.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>ops</span></div></a></li><li class="depth-2"><a href="claro.engine.html"><div class="inner"><span class="tree" style="top: -52px;"><span class="top" style="height: 61px;"></span><span class="bottom"></span></span><span>engine</span></div></a></li><li class="depth-3 branch"><a href="claro.engine.adapter.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>adapter</span></div></a></li><li class="depth-3"><a href="claro.engine.selector.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>selector</span></div></a></li><li class="depth-2"><div class="no-link"><div class="inner"><span class="tree" style="top: -83px;"><span class="top" style="height: 92px;"></span><span class="bottom"></span></span><span>middleware</span></div></div></li><li class="depth-3 branch"><a href="claro.middleware.cache.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>cache</span></div></a></li><li class="depth-3 branch"><a href="claro.middleware.deferred.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>deferred</span></div></a></li><li class="depth-3 branch"><a href="claro.middleware.intercept.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>intercept</span></div></a></li><li class="depth-3 branch"><a href="claro.middleware.mock.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>mock</span></div></a></li><li class="depth-3 branch"><a href="claro.middleware.observe.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>observe</span></div></a></li><li class="depth-3"><a href="claro.middleware.transform.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>transform</span></div></a></li><li class="depth-2"><a href="claro.projection.html"><div class="inner"><span class="tree" style="top: -207px;"><span class="top" style="height: 216px;"></span><span class="bottom"></span></span><span>projection</span></div></a></li></ul></div><div class="document" id="content"><div class="doc"><div class="markdown"><h1><a href="#testing-debugging" name="testing-debugging"></a>Testing &amp; Debugging</h1>
<p>Claro has a focus on introspectability and testability, so it offers some built-in ways of achieving both.</p>
<h3><a href="#separation-of-pure-and-impure-logic" name="separation-of-pure-and-impure-logic"></a>Separation of Pure and Impure Logic</h3>
<p>As outlined in <a href="00-basics.html">Basic Resolution</a>, you should use two protocols to implement resolvables:</p>
<ul>
  <li><code>Resolvable</code> for impure logic, like I/O.</li>
  <li><code>Transform</code> for pure logic, like transformations.</li>
</ul>
<p>So, instead of writing the following:</p>
<pre><code class="clojure">(defrecord Person [id]
  data/Resolvable
  (resolve! [_ env]
    (d/future
      (let [{:keys [friend-ids] :as person} (fetch-person! (:db env) id)]
        (-&gt; person
            (assoc :friends (map -&gt;Person friend-ids))
            (dissoc :friend-ids))))))
</code></pre>
<p>You should consider:</p>
<pre><code class="clojure">(defrecord Person [id]
  data/Resolvable
  (resolve! [_ env]
    (d/future
      (fetch-person! (:db env) id)))

  data/Transform
  (transform [_ {:keys [friend-ids] :as person}]
    (-&gt; person
        (assoc :friends (map -&gt;Person friend-ids))
        (dissoc :friend-ids))))
</code></pre>
<p>Sure, it’s a bit more verbose – but it also allows you to separately test your transformation logic:</p>
<pre><code class="clojure">(deftest t-person-transform
  (let [result (data/transform (-&gt;Person 1) {:id 1, :friend-ids [1 2 3]})]
    (is (= 1 (:id result)))
    (is (every? #(instance? Person %) (:friends result)))
    ...))
</code></pre>
<blockquote>
  <p><strong>Note:</strong> While a similar result can surely be achieved by extracting each transformation into a separately testable function, you cannot guarantee that said function is really used by the <code>Resolvable</code>.</p>
</blockquote>
<h3><a href="#mocks" name="mocks"></a>Mocks</h3>
<p>Another advantage of the approach described in the previous section is the fact that you can easily mock the impure part of your <code>Resolvable</code> using <a href="claro.middleware.mock.html#var-wrap-mock">wrap-mock</a>.</p>
<p>For example, to try out a projection on a <code>Person</code> record we could mock the respective query results:</p>
<pre><code class="clojure">(def run-engine
  (-&gt; (engine/engine)
      (wrap-mock
        Person
        (fn [{:keys [id]} env]
          {:id         id
           :name       "Person"
           :friend-ids [(inc id)]}))))
</code></pre>
<p>Which lets us do:</p>
<pre><code class="clojure">(-&gt; (-&gt;Person 1)
    (projection/apply {:friends [{:name projection/leaf}]})
    (run-engine)
    (deref))
</code></pre>
<p>Here’s the thing: <strong>Logic attached using the <code>Transform</code> protocol is still run</strong>, so if you want to craft a subtree with certain properties you have to think about what query result conveys these properties. For instance, to produce a person that has an empty <code>:friends</code> key your datastore has to return an empty list of <code>:friend-ids</code>.</p>
<p>Note that there is also <a href="claro.middleware.mock.html#var-wrap-mock-result">wrap-mock-result</a> which will skip transformations and just return whatever the function produces directly.</p>
<h3><a href="#introspection" name="introspection"></a>Introspection</h3>
<p>The namespace <a href="claro.middleware.observe.html">claro.middleware.observe</a> contains multiple middlewares that let you react to processing of single resolvables or resolvable batches, optionally using a predicate or list of classes.</p>
<p>For example, to trace the result of every <code>Person</code> resolution, we could use:</p>
<pre><code class="clojure">(defn trace-resolution
  [input output]
  (locking *out*
    (prn input '-&gt; output)))

(def run-engine
  (-&gt; (engine/engine)
      (wrap-observe-by-class [Person] trace-resolution)))
</code></pre>
<p>This will print a line every time we encounter a person.</p></div></div></div></body></html>